
#' Generates neighboring solutions (to a medoid representation) using a
#' pre-generated neighborhood matrix.
#' The generation method is as follows. From the medoid, 1 to num_clusters genes 
#' are randomly selected, each of these genes is replaced with a random neighboring
#' gene from the \code{neighborhood_matrix}. A gene is only replaced if the
#' replacement isn't currently in the solution.
#' 
#' @param exploration_size The amount of neighboring solutions to generate
#' @param num_clusters The number of clusters in a solution
#' @param solution A matrix with one solution.
#' @param neighborhood_matrix An adjacency matrix with all neighboring genes.
#' @param row_name_id An unique identifier that will be used to identify each row.
#' Its not changed inside this method, so when it is used it should be manually
#' updated after running this method.
#' @return A matrix with neighboring solutions.
#' 
helper.generate.neighborhood <- function(exploration_size, num_clusters, solution, neighborhood_matrix, row_name_id) {
  medoid_neighborhood <- as.data.frame( matrix(0, exploration_size, (num_clusters)), stringsAsFactors = FALSE )
  
  genes_with_neighbors <- solution[, 1:num_clusters]
  genes_with_neighbors <- genes_with_neighbors[(sapply(genes_with_neighbors, function(gene) {length(neighborhood_matrix[[gene]]) > 0}) ) ]
  
  for(medoid_generated in 1:nrow(medoid_neighborhood)) {
    medoid <- solution
    
    # Find genes that have at least 1 neighbor
    
    # Random neighborhood
    # Change a random amount of genes in the solution to a random neighboring gene.
    # genes_to_change <- sample(colnames(genes_with_neighbors), sample(1:length(genes_with_neighbors), 1))
    # for(gene_index in 1:length(genes_to_change)) {
    #   gene <- medoid[, genes_to_change[gene_index] ]
    #   neighbor_gene <- sample( neighborhood_matrix[[gene]], 1 )
    # 
    #   if( !(neighbor_gene %in% medoid[, 1:num_clusters]) ) {
    #     medoid[, gene_index] <- neighbor_gene
    #   }
    # }
    
    # 1 change to neighborhood
    # Changes a single gene to one of its neighbors
    gene <- sample(genes_with_neighbors, 1)[1, ]
    neighbor_gene <- sample( neighborhood_matrix[[gene]], 1 )

    gene_index <- sample(1:num_clusters, 1)
    if( !(neighbor_gene %in% medoid[, 1:num_clusters]) ) {
      medoid[, gene_index] <- neighbor_gene
    }
    
    medoid_neighborhood[medoid_generated, ] <- medoid[, 1:num_clusters]
  }
  
  #print( paste("Neighbors found:", nrow(medoid_neighborhood), "without duplication")  )
  medoid_neighborhood <- medoid_neighborhood[ !duplicated(medoid_neighborhood[, 1:num_clusters]), ]
  #print( paste("Neighbors found:", nrow(medoid_neighborhood), "removing duplication")  )
  medoid_neighborhood <- cbind(medoid_neighborhood, add=rep( FALSE,nrow(medoid_neighborhood) ) )
  rownames(medoid_neighborhood) <- sapply(rownames(medoid_neighborhood), function(unused) {
    row_name_id <<- row_name_id + 1
    paste("V", row_name_id, sep="")
  })
  
  return(medoid_neighborhood)
}

#' Helper for the Clustering ensemble local search method.
#' Generates all combinations between two medoids solutions without changing the
#' order of the genes in each medoid. In other words, creates 2^num_clusters -2
#' new solutions. The -2 is to skip creating the solutions equal to the medoids
#' being combined (\code{first_solution} and \code{second_solution}).
#' Since this calculation is exponential, it shouldn't be used with a num_clusters
#' greater than 10.
#' 
#' @param first_solution Vector or data.frame of genes. A medoid represented solution.
#' @param second_solution Vector or data.frame of genes. A medoid represented solution.
#' @param row_name_id An unique identifier that will be used to identify each row.
#' @return All medoids that can be generated by swapping the elements between
#' \code{first_solution} and \code{second_solution}.
#' @note It's not recommended to use ce local search with num_clusters greater than 8.
#' 
helper.generate.ensemble <- function(first_solution, second_solution, row_name_id) {
  num_clusters <- ncol(first_solution)
  medoid_ensemble <- as.data.frame( matrix(0, (2**num_clusters) - 2, num_clusters), stringsAsFactors = FALSE )
  
  for(row in 1:( nrow(medoid_ensemble) ) ) {
    for(col in 1:num_clusters) {
      if( bitwAnd(row, ( 2**(col-1) )) != 0 ) medoid_ensemble[row, col] <- first_solution[col]
      else medoid_ensemble[row, col] <- second_solution[col]        
    }
  }
  
  medoid_ensemble <- medoid_ensemble[ !duplicated(medoid_ensemble[, 1:num_clusters]), ]
  for( i in 1:nrow(medoid_ensemble) ) {
    solution <- medoid_ensemble[i, 1:num_clusters]
    if( sum( duplicated(t(solution)) ) > 0 ) {
      medoid_ensemble <- medoid_ensemble[-i, ]
    }
  }
  rownames(medoid_ensemble) <- sapply(rownames(medoid_ensemble), function(unused) {
    row_name_id <<- row_name_id + 1
    paste("V", row_name_id, sep="")
  })
  
  return(medoid_ensemble)
}

#' Calculate the probability based on the temperature and the difference of energy
#' between the new and old solution. Based on the work made by Yang et al.:
#' "A Simulated Annealing Approach to Find the Optimal Parameters for Fuzzy Clustering Microarray Data"
#' 
#' @param objective_exp Float value. Expression based objective of solution being evaluated.
#' @param objective_bio Float value. Biologic based objective of solution being evaluated.
#' @param solution Solution compared to. Data frame or list that has to contain the
#' following columns: $objective_exp and $objective_bio
#' @return Value between 0 and 1. Probability of accepting this solution.
#'
helper.mosa.probability <- function(objective_exp, objective_bio, solution, temperature)
{
  Energy <- sqrt((solution$objective_exp - objective_exp)**2 + (solution$objective_bio - objective_bio)**2)
  probability <- exp(-(Energy/temperature)) # Probablidad boltzman
}

#' Modifies the archive adding the new found solutions and reorders the rank of the
#' solutions. It cuts off solutions with rank worse than \code{rank_cutoff}.
#' It maintains information referencing whether the solutions were explored or not.
#' 
#' @param archive Data frame of medoid solutions
#' @param add_to_archive Data frame of new medoid solutions
#' @param gene_list Vector of all available genes.
#' @param num_cluster Integer of the number of clusters.
#' @param ordering_fn Function used to order the archive
#' @param rank_cutoff Integer. Solutions with a rank > than this get deleted.
#' @return archive of solutions with the new solutions added as unexplored after
#' cutting off all solutions with a bad rank.
#' 
helper.cut.and.join.archive <- function(archive, add_to_archive, gene_list, num_clusters, ordering_fn, rank_cutoff) {
  explored <- archive[ , "explored", drop=FALSE]
  new_archive <- helper.randomize.duplicates( rbind( archive[, 1:num_clusters], add_to_archive), gene_list, num_clusters )
  archive <- ordering_fn(new_archive, dmatrix_expression, dmatrix_biological)
  archive <- archive[archive$solutions_rank <= rank_cutoff, ]
  
  new_solutions <- rownames( archive[!( rownames(archive) %in% rownames(explored) ), ] )
  new_solutions <- as.data.frame(rep( FALSE,length(new_solutions) ), stringsAsFactors = FALSE)
  rownames(new_solutions) <- rownames( archive[!( rownames(archive) %in% rownames(explored) ), ] )
  colnames(new_solutions) <- "explored"
  
  explored <- explored[ rownames(explored) %in% rownames(archive) , , drop=FALSE]
  explored <- rbind( new_solutions, explored )
  
  explored <- explored[ order(row.names(explored)), , drop=FALSE ]
  archive <- archive[ order(row.names(archive)), , drop=FALSE ]
  archive <- cbind( archive, explored )
  
  return( archive )
}

#' Non-dominance acceptance function.
#' 
#' @param objective_exp Float value. Expression based objective of solution being evaluated.
#' @param objective_bio Float value. Biologic based objective of solution being evaluated.
#' @param solution Solution compared to. Data frame or list that has to contain the
#' following columns: $objective_exp and $objective_bio
#' @return boolean value indicating if the solution passes the non-dominance criteria.
#' 
helper.non.dominated <- function(objective_exp, objective_bio, solution) {
  return( objective_bio < solution$objective_bio || objective_exp < solution$objective_exp )
}

#' Dominance acceptance function.
#' 
#' @param objective_exp Float value. Expression based objective of solution being evaluated.
#' @param objective_bio Float value. Biologic based objective of solution being evaluated.
#' @param solution Solution compared to. Data frame or list that has to contain the
#' following columns: $objective_exp and $objective_bio
#' @return boolean value indicating if the solution passes the dominance criteria.
#' 
helper.dominates <- function(objective_exp, objective_bio, solution) {
  return( ( objective_bio <= solution$objective_bio && objective_exp < solution$objective_exp ) ||
          ( objective_bio < solution$objective_bio && objective_exp <= solution$objective_exp ) )
}

#' Pareto Local Search
#' 
#' @param exploration_size Integer value. How many solutions should be explored each
#' iteration. Usually, the population_size of NSGA-II is used.
#' @param population Matrix / data.frame. Each row represents a solution.
#' @param num_clusters Integer value. How many medoids each solution has.
#' @param gene_list Vector. All the genes that can be used in the population. These
#' names should match the rows and cols of dmatrix_expression and dmatrix_biological. 
#' @param dmatrix_expression Gene expression distance matrix between each pair of genes.
#' @param dmatrix_biological Biological distance matrix between each pair of genes.
#' @param neighborhood_matrix Distance matrix. How close each pair of genes is based on
#' its expression and biological distance.
#' @param ordering_fn Function used to sort the population. 
#' Usually uses operator.nsga2.sorting.and.crowding .
#' @param fitness_fn Function used to calculate objectives. Usually uses fitness.medoid.wg
#' @param acceptance_criteria_fn Function used to accept a new solution into the
#' population archive. 3 parameters, new_objective_exp, new_objective_bio and old_solution
#' @param rank_cutoff Integer value. Solutions below this rank are removed from the archive.
#' @param max_generations Integer value. Maximum number of iterations.
#' 
#' @return matrix of new pareto front found by PLS.
#' 
local.search.pareto.local.search <- function(exploration_size, population, num_clusters, gene_list, dmatrix_expression, dmatrix_biological, neighborhood_matrix, ordering_fn, fitness_fn, acceptance_criteria_fn = helper.non.dominated, rank_cutoff = 2, max_generations = 100) {
  
  # Create the archive of solutions
  archive <- ordering_fn(population[, 1:num_clusters], dmatrix_expression, dmatrix_biological)
  archive <- cbind( archive, explored=rep( FALSE,nrow(archive) ) )
  archive <- archive[archive$solutions_rank <= rank_cutoff, ]
  
  g <- 1
  row_name_id <- 0
  
  # Loop until max_generations or until there are no unexplored solutions
  while( sum(archive[, ncol(archive)]) < nrow(archive) && g <= max_generations ) {
    # Choose an unexplored solution
    print(paste(g, "-", fitness_counter))
    unexplored <- archive[archive$explored == FALSE, , drop=FALSE]
    row_index <- rownames( unexplored[ sample(nrow(unexplored), 1), ] )[1]
    solution <- unexplored[row_index, , drop=FALSE]
    
    # Generate neighborhood
    medoid_neighborhood <- helper.generate.neighborhood(round(exploration_size/2), num_clusters, solution, neighborhood_matrix, row_name_id)
    row_name_id <- row_name_id + exploration_size + 1
    
    # Check if any neighboring solutions pass the acceptance criteria
    for(i in 1:nrow(medoid_neighborhood)) {
      objective_exp <- fitness_fn( medoid_neighborhood[i, 1:num_clusters], dmatrix_expression, 'expression' )
      objective_bio <- fitness_fn( medoid_neighborhood[i, 1:num_clusters], dmatrix_biological, 'biological' )
      
      if( acceptance_criteria_fn(objective_exp, objective_bio, solution) ) {
        medoid_neighborhood[i, "add"] <- TRUE
      }
    }
    
    # Add solutions found in the neighborhood if there are any that passed the
    # acceptance criteria used
    if( sum(medoid_neighborhood[, ncol(medoid_neighborhood)]) > 1 ) {
      archive <- helper.cut.and.join.archive(
        archive, 
        medoid_neighborhood[ medoid_neighborhood$add == TRUE, 1:(num_clusters) ],
        gene_list, num_clusters, ordering_fn, rank_cutoff = rank_cutoff
      )
    }
    
    # Mark solution as explored if it still is in the archive
    if( row_index %in% rownames(archive) ) {
      archive[row_index, ncol(archive)] = TRUE
    }
    g <- g + 1
  }
  
  # Clean the results and return them
  archive <- helper.randomize.duplicates( archive, gene_list, num_clusters )
  archive <- ordering_fn(archive[, 1:num_clusters], dmatrix_expression, dmatrix_biological)
  
  print( paste("Pareto local search ran for", g, "iterations") )
  return( archive )
}

#' Large Multiobjective local search
#' 
#' @param exploration_size Integer value. How many solutions should be explored each
#' iteration. Usually, the population_size of NSGA-II is used.
#' @param population Matrix / data.frame. Each row represents a solution.
#' @param num_clusters Integer value. How many medoids each solution has.
#' @param gene_list Vector. All the genes that can be used in the population. These
#' names should match the rows and cols of dmatrix_expression and dmatrix_biological. 
#' @param dmatrix_expression Gene expression distance matrix between each pair of genes.
#' @param dmatrix_biological Biological distance matrix between each pair of genes.
#' @param neighborhood_matrix Distance matrix. How close each pair of genes is based on
#' its expression and biological distance.
#' @param ordering_fn Function used to sort the population. 
#' Usually uses operator.nsga2.sorting.and.crowding .
#' @param fitness_fn Function used to calculate objectives. Usually uses fitness.medoid.wg
#' 
#' @return Matrix of neighboring solutions that pass the non-dominance criteria.
#' 
local.search.large.mols <- function(exploration_size, population, num_clusters, gene_list, dmatrix_expression, dmatrix_biological, neighborhood_matrix, ordering_fn, fitness_fn) {
  
  population <- ordering_fn(population[, 1:num_clusters], dmatrix_expression, dmatrix_biological)
  archive <- population[1, 1:num_clusters, drop=FALSE]
  
  row_name_id <- 0
  
  # Explore the neighbors of every solution in the population
  for(row_index in 1:nrow(population)) {
    
    solution <- population[row_index, , drop=FALSE]
    medoid_neighborhood <- helper.generate.neighborhood(exploration_size, num_clusters, solution, neighborhood_matrix, row_name_id)
    row_name_id <- row_name_id + exploration_size + 1
    
    for(i in 1:nrow(medoid_neighborhood)) {
      objective_exp <- fitness_fn( medoid_neighborhood[i, 1:num_clusters], dmatrix_expression, 'expression' )
      objective_bio <- fitness_fn( medoid_neighborhood[i, 1:num_clusters], dmatrix_biological, 'biological' )
      
      if( helper.non.dominated(objective_exp, objective_bio, solution) ) {
        archive <- rbind(archive, medoid_neighborhood[i, 1:num_clusters])
      }
    }
  }
  
  return( archive )
}

#' Narrow Multiobjective local search
#' 
#' @param exploration_size Integer value. How many solutions should be explored each
#' iteration. Usually, the population_size of NSGA-II is used.
#' @param population Matrix / data.frame. Each row represents a solution.
#' @param num_clusters Integer value. How many medoids each solution has.
#' @param gene_list Vector. All the genes that can be used in the population. These
#' names should match the rows and cols of dmatrix_expression and dmatrix_biological. 
#' @param dmatrix_expression Gene expression distance matrix between each pair of genes.
#' @param dmatrix_biological Biological distance matrix between each pair of genes.
#' @param neighborhood_matrix Distance matrix. How close each pair of genes is based on
#' its expression and biological distance.
#' @param ordering_fn Function used to sort the population. 
#' Usually uses operator.nsga2.sorting.and.crowding .
#' @param fitness_fn Function used to calculate objectives. Usually uses fitness.medoid.wg
#' 
#' @return Matrix of neighboring solutions that pass the dominance criteria.
#' 
local.search.narrow.mols <- function(exploration_size, population, num_clusters, gene_list, dmatrix_expression, dmatrix_biological, neighborhood_matrix, ordering_fn, fitness_fn) {
  
  population <- ordering_fn(population[, 1:num_clusters], dmatrix_expression, dmatrix_biological)
  archive <- population[1, 1:num_clusters, drop=FALSE]
  
  row_name_id <- 0
  
  # Explore the neighbors of every solution in the population
  for(row_index in 1:nrow(population)) {
    
    solution <- population[row_index, , drop=FALSE]
    medoid_neighborhood <- helper.generate.neighborhood(exploration_size, num_clusters, solution, neighborhood_matrix, row_name_id)
    row_name_id <- row_name_id + exploration_size + 1
    
    for(i in 1:nrow(medoid_neighborhood)) {
      objective_exp <- fitness_fn( medoid_neighborhood[i, 1:num_clusters], dmatrix_expression, 'expression' )
      objective_bio <- fitness_fn( medoid_neighborhood[i, 1:num_clusters], dmatrix_biological, 'biological' )
      
      if( helper.dominates(objective_exp, objective_bio, solution) ) {
        archive <- rbind(archive, medoid_neighborhood[i, 1:num_clusters])
      }
    }
  }
  
  return( archive )
}

#' Multiobjective simulated annealing
#' 
#' @param exploration_size Integer value. How many solutions should be explored each
#' iteration. Usually, the population_size of NSGA-II is used.
#' @param population Matrix / data.frame. Each row represents a solution.
#' @param num_clusters Integer value. How many medoids each solution has.
#' @param gene_list Vector. All the genes that can be used in the population. These
#' names should match the rows and cols of dmatrix_expression and dmatrix_biological. 
#' @param dmatrix_expression Gene expression distance matrix between each pair of genes.
#' @param dmatrix_biological Biological distance matrix between each pair of genes.
#' @param neighborhood_matrix Distance matrix. How close each pair of genes is based on
#' its expression and biological distance.
#' @param ordering_fn Function used to sort the population. 
#' Usually uses operator.nsga2.sorting.and.crowding .
#' @param fitness_fn Function used to calculate objectives. Usually uses fitness.medoid.wg
#' @param rank_cutoff Integer value. Solutions below this rank are removed from the archive.
#' @param alfa Float value. Factor used for geomtric cooling.
#' @param max_steps Integer value. How many steps does the cooling goes on for. Iterations.
#' @param intial_temperature Float value. Intial temperature used in the geometric cooling.
#' 
#' @return Matrix of neighboring solutions that pass the non-dominance criteria.
#' 
local.search.mosa <- function(exploration_size, population, num_clusters, gene_list, dmatrix_expression, dmatrix_biological, neighborhood_matrix, ordering_fn, fitness_fn, acceptance_criteria_fn = helper.non.dominated, rank_cutoff = 5, alfa = 0.95, max_steps = 1000, inital_temperature = 100) {
  
  archive <- ordering_fn(population[, 1:num_clusters], dmatrix_expression, dmatrix_biological)
  archive <- cbind( archive, explored=rep( FALSE,nrow(archive) ) )
  archive <- archive[archive$solutions_rank <= rank_cutoff, ]
  
  row_name_id <- 0
  
  for(step in 1:max_steps) {
    print(paste(step, "-", fitness_counter))
    # Geometric cooling
    temperature <- (alfa**step) * inital_temperature
    
    row_index <- rownames( archive[ sample(nrow(archive), 1), ] )[1]
    solution <- archive[row_index, , drop=FALSE]
    
    # Generate neighborhood
    medoid_neighborhood <- helper.generate.neighborhood(round(exploration_size/10), num_clusters, solution, neighborhood_matrix, row_name_id)
    row_name_id <- row_name_id + exploration_size + 1
    
    for(i in 1:nrow(medoid_neighborhood)) {
      objective_exp <- fitness_fn( medoid_neighborhood[i, 1:num_clusters], dmatrix_expression, 'expression' )
      objective_bio <- fitness_fn( medoid_neighborhood[i, 1:num_clusters], dmatrix_biological, 'biological' )
      
      # If it passes the acceptance criteria or if it has enough probability
      if( acceptance_criteria_fn(objective_exp, objective_bio, solution) ||
          runif(1) < helper.mosa.probability(objective_exp, objective_bio, solution, temperature) ) {
        medoid_neighborhood[i, num_clusters+1] <- TRUE
      }
    }
    
    if( sum(medoid_neighborhood[, ncol(medoid_neighborhood)]) > 1 ) {
      archive <- helper.cut.and.join.archive(
        archive, 
        medoid_neighborhood[ medoid_neighborhood$add == TRUE, 1:num_clusters ],
        gene_list, num_clusters, ordering_fn, rank_cutoff = rank_cutoff 
      )
    }
    
    #print(paste(step, temperature, sep=" - "))
    #print(archive)
  }
  archive <- helper.randomize.duplicates( archive, gene_list, num_clusters )
  archive <- ordering_fn(archive[, 1:num_clusters], dmatrix_expression, dmatrix_biological)
  
  print( paste("Multiobjective simulated annealing ran for", step, "iterations") )
  return( archive )
}

#' Multiobjective clustering ensemble local search
#' 
#' @param exploration_size Integer value. How many solutions should be explored each
#' iteration. Usually, the population_size of NSGA-II is used.
#' @param population Matrix / data.frame. Each row represents a solution.
#' @param num_clusters Integer value. How many medoids each solution has.
#' @param gene_list Vector. All the genes that can be used in the population. These
#' names should match the rows and cols of dmatrix_expression and dmatrix_biological. 
#' @param dmatrix_expression Gene expression distance matrix between each pair of genes.
#' @param dmatrix_biological Biological distance matrix between each pair of genes.
#' @param neighborhood_matrix Distance matrix. How close each pair of genes is based on
#' its expression and biological distance.
#' @param ordering_fn Function used to sort the population. 
#' Usually uses operator.nsga2.sorting.and.crowding .
#' @param fitness_fn Function used to calculate objectives. Usually uses fitness.medoid.wg
#' @param rank_cutoff Integer value. Solutions below this rank are removed from the archive.
#' 
#' @return Matrix of solutions created by combining the top solutions in the population.
#' 
local.search.ensemble <- function(exploration_size, population, num_clusters, gene_list, dmatrix_expression, dmatrix_biological, ordering_fn, fitness_fn, rank_cutoff = 1) {
  
  archive <- ordering_fn(population[, 1:num_clusters], dmatrix_expression, dmatrix_biological)
  archive <- archive[archive$solutions_rank <= rank_cutoff, ]
  archive <- cbind( archive, explored=rep( FALSE,nrow(archive) ) )
  
  new_archive <- archive[1, 1:num_clusters, drop=FALSE]
  
  step <- 0
  row_name_id <- 0
  
  # Combine each pair of solutions in the top rank_cutoff ranks.
  for(first_idx in 1:nrow(archive)) {
    for(second_idx in (first_idx + 1):nrow(archive)) {
      #print(paste("[", first_idx, ", ", second_idx, "]", sep=""))
      if( second_idx > nrow(archive) || second_idx == first_idx) next
      
      medoid_combinations <- helper.generate.ensemble(archive[first_idx, 1:num_clusters], archive[second_idx, 1:num_clusters], row_name_id)
      row_name_id <- row_name_id + (2**num_clusters) + 1
      
      for (i in 1:nrow(medoid_combinations)) {
        objective_exp <- fitness_fn( medoid_combinations[i, 1:num_clusters], dmatrix_expression, 'expression' )
        objective_bio <- fitness_fn( medoid_combinations[i, 1:num_clusters], dmatrix_biological, 'biological' )
        
        if( helper.non.dominated(objective_exp, objective_bio, archive[first_idx, ]) ||
            helper.non.dominated(objective_exp, objective_bio, archive[second_idx, ]) ) {
          
          # This process may find duplicates. At the end of this algorithm this is addressed.
          new_archive <- rbind(new_archive, medoid_combinations[i, 1:num_clusters, drop=FALSE])
        }
      }
      
      step <- step + 1
      #print(step)
    }
  }
  
  new_archive <- helper.randomize.duplicates(new_archive, gene_list, num_clusters)
  
  print( paste("Clustering ensemble ran for", step, "iterations") )
  return( new_archive )
}